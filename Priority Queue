------------PRIORITY QUEUE-------



************MINIMUM COST TO MAKE LONGEST CHAIN************


import java.util.*;

class BeingZero {

    public int solve(int[] arr, int n) {

        PriorityQueue<Integer> mnpq = new PriorityQueue<>();

        // Insert all chain lengths into min heap
        for (int x : arr) {
            mnpq.add(x);
        }

        int totalCost = 0;

        // Join until one chain remains
        while (mnpq.size() > 1) {

            int x = mnpq.poll();
            int y = mnpq.poll();

            int cost = x + y;
            totalCost += cost;

            // Push the joined chain back
            mnpq.add(cost);
        }

        return totalCost;
    }
}




*******************RUNNING MEDIAN***********


Description

You are given a stream of N integers. After inserting each number into the data structure, you must output the median of all elements seen so far.
The median is defined as:
If the number of elements is odd, the middle element
If the number of elements is even, the average of the two middle elements


import java.util.*;

class BeingZero {

    public float[] solve(int A[], int n) {

        float[] ans = new float[n];

        // Max heap (left side)
        PriorityQueue<Integer> mxpq =
                new PriorityQueue<>(Collections.reverseOrder());

        // Min heap (right side)
        PriorityQueue<Integer> mnpq =
                new PriorityQueue<>();

        for (int i = 0; i < n; i++) {

            int x = A[i];

            // Adding step
            if (mxpq.isEmpty() || x <= mxpq.peek()) {
                mxpq.add(x);
            } else {
                mnpq.add(x);
            }

            // Balancing step
            if (Math.abs(mxpq.size() - mnpq.size()) > 1) {
                if (mxpq.size() > mnpq.size()) {
                    mnpq.add(mxpq.poll());
                } else {
                    mxpq.add(mnpq.poll());
                }
            }

            // Finding median
            if (mxpq.size() == mnpq.size()) {
                ans[i] = (mxpq.peek() + mnpq.peek()) / 2.0f;
            } else if (mxpq.size() > mnpq.size()) {
                ans[i] = mxpq.peek();
            } else {
                ans[i] = mnpq.peek();
            }
        }

        return ans;
    }
}


*************MEETING ROOM  ************



You are given a 2D integer array A of size N x 2 where each row represents a meeting time interval.
A[i][0] → Start time of the i-th meeting
A[i][1] → End time of the i-th meeting
Your task is to determine the minimum number of conference rooms required so that all meetings can be scheduled without conflicts.
Note
If a meeting ends at time t, another meeting starting at time t can use the same room.



import java.util.*;

class BeingZero {

    public int solve(int[][] intervals, int n) {

        if (n == 0)
            return 0;

        // Sort meetings by start time
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        // Min heap to store end times
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        // Add end time of first meeting
        pq.add(intervals[0][1]);
        for (int i = 1; i < n; i++) {
            // If room can be reused
            if (intervals[i][0] >= pq.peek()) {
                pq.poll();
            }
            // Add current meeting end time
            pq.add(intervals[i][1]);
        }

        // Size of heap = number of rooms required
        return pq.size();
    }
}

*********************FRACTIONAL KNAPSACK******************


You are given N items, each having a weight and a value, and a knapsack with a maximum weight capacity W.
You are allowed to take fractions of items, meaning you can split an item and take only a part of it if needed.
Your task is to maximize the total value placed in the knapsack without exceeding its weight capacity.



import java.util.*;

// Class representing an item
class Item {
    int value, weight;

    Item(int value, int weight) {
        this.value = value;
        this.weight = weight;
    }
}

class BeingZero {

    static double fractionalKnapsack(int W, Item[] arr, int n) {

        // Sort items by value/weight ratio (descending)
        Arrays.sort(arr, (a, b) -> {
            double r1 = (double) a.value / a.weight;
            double r2 = (double) b.value / b.weight;
            return Double.compare(r2, r1);
        });

        int curWeight = 0;
        double finalValue = 0.0;

        // Pick items greedily
        for (int i = 0; i < n; i++) {

            if (curWeight + arr[i].weight <= W) {
                curWeight += arr[i].weight;
                finalValue += arr[i].value;
            } else {
                int remain = W - curWeight;
                finalValue += ((double) arr[i].value / arr[i].weight) * remain;
                break;
            }
        }

        return finalValue;
    }

    public static void main(String[] args) {
        int n = 3;
        int W = 50;
        Item[] arr = {
            new Item(100, 20),
            new Item(60, 10),
            new Item(120, 30)
        };
        System.out.println("The maximum value is " +
                fractionalKnapsack(W, arr, n));
    }
}





